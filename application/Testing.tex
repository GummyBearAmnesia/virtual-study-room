\documentclass{article}
\usepackage{graphicx}
\usepackage{xcolor}

\begin{document}

\title{\textbf{Testing Strategy and Evaluation}}
\author{}
\date{}

\maketitle

\section{Testing Strategy}

\subsection{6.1 Testing Approach}
Our testing approach was a mix of unit testing, integration testing, and manual user testing. We aimed for high test coverage while keeping the process efficient and practical.

\begin{itemize}
    \item \textbf{Unit Testing:} We used Djangoâ€™s built-in testing framework to cover backend logic and API endpoints, while Jest was used to test React components on the frontend.
    \item \textbf{Integration Testing:} WebSockets and API interactions were tested to ensure that real-time updates worked correctly.
    \item \textbf{User Testing:} We conducted manual user testing to validate the UI, interactions, and overall user experience.
\end{itemize}

We followed a test-as-you-go approach, meaning tests were written as soon as a feature was implemented. This helped us identify issues early rather than waiting until the end of development.

\subsection{6.2 Automated Tests}
Our automated tests included:

\begin{itemize}
    \item \textbf{Backend:} Django tests covered key functionalities, including authentication, WebSocket communication, and database operations.
    \item \textbf{Frontend:} Jest tests focused on user interface components, user interactions, and state updates.
    \item \textbf{End-to-End (E2E) Testing:} Some integration tests were performed manually, particularly for WebSocket-driven features in real time.
\end{itemize}

Currently, our test coverage stands at:
\begin{itemize}
    \item \textbf{Backend:} 93\%
    \item \textbf{Frontend:} 85\%
\end{itemize}

\textbf{Commands to Run Tests:}

\textbf{Backend (Django):}
\begin{verbatim}
python manage.py test
\end{verbatim}

\textbf{To generate a backend coverage report:}
\begin{verbatim}
coverage run manage.py test 
coverage report -m (or coverage html)
\end{verbatim}

\textbf{Frontend (React, Jest):}
\begin{verbatim}
npm test
\end{verbatim}

\textbf{To generate a frontend coverage report:}
\begin{verbatim}
npm test -- --coverage  (or npx test -- --coverage)
\end{verbatim}

\subsection{6.3 Evaluation of Our Testing Approach}
\textbf{What Worked Well:}
\begin{itemize}
    \item \textbf{High test coverage:} With the 93\% back-end and 85\% front-end coverage, we achieved strong validation for most functionalities.
    \item \textbf{Early testing:} Writing tests alongside development helped us catch issues quickly.
    \item \textbf{Automated checks:} Tests helped prevent regressions before deployment.
\end{itemize}

\textbf{Challenges:}
\begin{itemize}
    \item \textbf{Test Maintenance:} One downside was that whenever we refactored React components to make them cleaner and more efficient, existing Jest tests often broke and had to be updated.
    \item \textbf{Real-time testing:} WebSocket features required manual testing in some cases, as automating real-time interactions can be complex.
\end{itemize}

\textbf{Conclusion:}  
Overall, our testing strategy gave us confidence in the reliability of the system. The main challenge was keeping frontend tests up-to-date during refactoring. In the future, we could improve this by using more snapshot testing and writing tests that are less dependent on specific component structures.

\end{document}
